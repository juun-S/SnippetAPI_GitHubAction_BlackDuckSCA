name: Black Duck Snippet Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  snippet-scan:
    name: Black Duck Snippet Scan
    runs-on: ubuntu-latest

    env:
      BLACKDUCKSCA_URL: ${{ vars.BLACKDUCKSCA_URL }}
      BLACKDUCKSCA_TOKEN: ${{ secrets.BLACKDUCKSCA_TOKEN }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # fetch-depth: 0 ensures the runner checks out the entire git history,
        # which guarantees that both the base and head SHAs are available for the git diff command.
        with:
          fetch-depth: 0

      - name: Extract changed code from Pull Request
        id: extract_code
        run: |
          git diff --unified=0 ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} \
          | awk 'BEGIN {OFS=""} /^diff --git/ {nextfile} /^\+\+\+/ {next} /^\+/ {print substr($0, 2)}' \
          > changed_code.txt

          if [ -s changed_code.txt ]; then
            echo "--- Code Snippets to be Scanned ---"
            cat changed_code.txt
            echo "-----------------------------------"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "No new code changes detected in this Pull Request."
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Scan snippet with Black Duck API
        if: steps.extract_code.outputs.changed == 'true'
        id: bd_scan
        run: |
          MIN_SIZE=300  # bytes
          MAX_SIZE=50000 # bytes
          CODE_SIZE=$(wc -c < changed_code.txt)

          if [ "$CODE_SIZE" -lt "$MIN_SIZE" ]; then
            echo "::notice::Code changes are too small (${CODE_SIZE} bytes) to be scanned. Skipping Black Duck Snippet Scan."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$CODE_SIZE" -gt "$MAX_SIZE" ]; then
            echo "::warning::Code changes are too large (${CODE_SIZE} bytes) for a single scan. Please consider splitting the changes into smaller Pull Requests."
            # Optionally, create a comment on the PR
            # gh pr comment ${{ github.event.pull_request.number }} --body "⚠️ **Warning:** The number of changes in this PR is too large to be scanned by Black Duck in a single operation. Please split this PR into smaller ones if a snippet scan is required."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Code size (${CODE_SIZE} bytes) is within the scannable range."

          # --- Start of existing scan logic ---

          AUTH_RESPONSE_FILE=$(mktemp)
          # 스크립트 종료 시 임시 파일 자동 삭제
          trap 'rm -f "$AUTH_RESPONSE_FILE"' EXIT

          AUTH_HTTP_CODE=$(curl -s -o "$AUTH_RESPONSE_FILE" -w "%{http_code}" -X POST \
            --header "Authorization: token ${BLACKDUCKSCA_TOKEN}" \
            "${BLACKDUCKSCA_URL}/api/tokens/authenticate")
          
          if [ "$AUTH_HTTP_CODE" -ne 200 ]; then
            echo "::error::Failed to get Bearer Token from Black Duck (HTTP Code: $AUTH_HTTP_CODE)"
            echo "::error::Response: $(cat $AUTH_RESPONSE_FILE)"
            exit 1
          fi

          BEARER_TOKEN=$(jq -r '.bearerToken' "$AUTH_RESPONSE_FILE")
          if [ -z "$BEARER_TOKEN" ] || [ "$BEARER_TOKEN" == "null" ]; then
            echo "::error::Bearer Token is empty. Authentication failed."
            echo "::error::Response: $AUTH_BODY"
            exit 1
          fi
          echo "Successfully obtained Bearer Token."

          SCAN_RESPONSE_FILE=$(mktemp)
          # 스크립트 종료 시 임시 파일 자동 삭제
          trap 'rm -f "$AUTH_RESPONSE_FILE" "$SCAN_RESPONSE_FILE"' EXIT

          SCAN_HTTP_CODE=$(curl -s -o "$SCAN_RESPONSE_FILE" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${BEARER_TOKEN}" \
            -H "Content-Type: text/plain" \
            -H "Accept: application/json" \
            --data-binary @changed_code.txt \
            "${BLACKDUCKSCA_URL}/api/snippet-matching")

          if [ "$SCAN_HTTP_CODE" -ne 200 ]; then
            echo "::error::Black Duck Snippet Scan API call failed (HTTP Code: $SCAN_HTTP_CODE)"
            echo "::error::Response: $(cat $SCAN_RESPONSE_FILE)"
            exit 1
          fi

          cat "$SCAN_RESPONSE_FILE" > scan_results.json
          echo "scan_completed=true" >> $GITHUB_OUTPUT
          echo "Snippet scan completed successfully."

      - name: Process scan results and comment on PR
        if: steps.bd_scan.outputs.scan_completed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const core = require('@actions/core');
            const path = require('path');
            const resultsPath = path.join(process.env.GITHUB_WORKSPACE, 'scan_results.json');
            
            if (!fs.existsSync(resultsPath)) {
              console.log('scan_results.json not found. Skipping comment.');
              return;
            }

            const response = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
            const results = response.items || [];

            if (results.length === 0) {
              console.log('No snippet matches found.');
              return;
            }

            let high_risk_found = false;
            let comment_body = '### :shield: Black Duck Snippet Scan Results\n\n';
            comment_body += 'The following open source snippets were detected in the added code:\n\n';
            
            const highRiskFamilies = ['RECIPROCAL', 'AGPL'];
            const mediumRiskFamilies = ['WEAK_RECIPROCAL'];

            let table_header = '| Risk | Component | Version | License | License Family |\n';
            table_header += '|:----:|:----------|:--------|:--------|:---------------|\n';
            let table_body = '';

            for (const match of results) {
              const component = match.matchingComponent || 'N/A';
              const version = match.version || 'N/A';
              const license = match.licenseName || 'UNKNOWN';
              const family = match.licenseFamily || 'UNKNOWN';
              
              let emoji = '🟢'; // Low risk
              if (highRiskFamilies.includes(family)) {
                emoji = '🔴'; // High risk
                high_risk_found = true;
              } else if (mediumRiskFamilies.includes(family)) {
                emoji = '🟡'; // Medium risk
              }
              
              table_body += `| ${emoji} | `${component}` | `${version}` | ${license} | ${family} |\n`;
            }

            comment_body += table_header + table_body;

            if (high_risk_found) {
              comment_body += '\n\n**Action Required:** 🔴 High-risk license(s) (Reciprocal, AGPL) detected. A review from the legal/compliance team is required before merging.';
              core.setFailed('High-risk license snippets detected.');
            } else {
              comment_body += '\n\n**Notice:** 🟢 All detected snippets are within the acceptable license policy range.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment_body
            });
