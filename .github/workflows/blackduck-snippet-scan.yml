name: Black Duck Snippet Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  snippet-scan:
    name: Black Duck Snippet Scan
    runs-on: ubuntu-latest

    env:
      BLACKDUCKSCA_URL: ${{ vars.BLACKDUCKSCA_URL }}
      BLACKDUCKSCA_TOKEN: ${{ secrets.BLACKDUCKSCA_TOKEN }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # fetch-depth: 0ÏùÄ Ï†ÑÏ≤¥ git ÌûàÏä§ÌÜ†Î¶¨Î•º Ï≤¥ÌÅ¨ÏïÑÏõÉÌïòÏó¨,
        # git diff Î™ÖÎ†πÏóê ÌïÑÏöîÌïú baseÏôÄ head SHAÎ•º Î™®Îëê ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Î≥¥Ïû•Ìï©ÎãàÎã§.
        with:
          fetch-depth: 0

      - name: Extract changed code from Pull Request
        id: extract_code
        run: |
          # --- ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ Ï∂úÎ†• ÏãúÏûë ---
          echo "::group::Debugging Git Information"
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"
          echo "Current Branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Verifying SHAs are present:"
          git cat-file -t ${{ github.event.pull_request.base.sha }} || echo "Base SHA not found locally!"
          git cat-file -t ${{ github.event.pull_request.head.sha }} || echo "Head SHA not found locally!"
          echo "::endgroup::"

          echo "::group::Raw git diff output"
          # awkÎ°ú ÌååÏù¥ÌîÑÌïòÍ∏∞ Ï†ÑÏùò ÏõêÎ≥∏ diff Í≤∞Í≥ºÎ•º Ï∂úÎ†•ÌïòÏó¨ Ïã§Ï†ú Î≥ÄÍ≤Ω ÎÇ¥Ïö©Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
          git diff --unified=0 ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }}
          echo "::endgroup::"
          # --- ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ Ï∂úÎ†• ÎÅù ---

          # PRÏùò Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ÏùÑ Í∞ÄÏû• ÏïàÏ†ïÏ†ÅÏúºÎ°ú Ï∂îÏ∂úÌïòÍ∏∞ ÏúÑÌï¥ 'three-dot' diff (...)Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
          # Ïù¥Îäî 'base'ÏôÄ 'head'Ïùò Í≥µÌÜµ Ï°∞ÏÉÅÍ≥º 'head'Î•º ÎπÑÍµêÌïòÏó¨, Ïù¥ PRÏóêÏÑú Î∞úÏÉùÌïú ÏàúÏàòÌïú Î≥ÄÍ≤ΩÎ∂ÑÎßå Í∞ÄÏ†∏ÏòµÎãàÎã§.
          # diff Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î•º ÌïÑÌÑ∞ÎßÅÌïòÍ≥† ÏàúÏàò ÏΩîÎìú ÎùºÏù∏Îßå ÌååÏùºÏóê Ï†ÄÏû•Ìï©ÎãàÎã§.
          git diff --unified=0 ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }} \
            | awk 'BEGIN {OFS=""} /^(diff|index|---)/ {next} /^\+\+\+/ {next} /^\+/ {print substr($0, 2)}' \
            > changed_code.txt

          if [ -s changed_code.txt ]; then
            echo "--- Code Snippets to be Scanned ---"
            cat changed_code.txt
            echo "-----------------------------------"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "No added or modified code lines found to scan in this Pull Request. Skipping snippet scan."
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Scan snippet with Black Duck API
        if: steps.extract_code.outputs.changed == 'true'
        id: bd_scan
        run: |
          MIN_SIZE=300    # Î∞îÏù¥Ìä∏ Îã®ÏúÑ
          MAX_SIZE=50000  # Î∞îÏù¥Ìä∏ Îã®ÏúÑ
          CODE_SIZE=$(wc -c < changed_code.txt)

          if [ "$CODE_SIZE" -lt "$MIN_SIZE" ]; then
            echo "::notice::Code changes are too small (${CODE_SIZE} bytes) to be scanned. Skipping Black Duck Snippet Scan."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$CODE_SIZE" -gt "$MAX_SIZE" ]; then
            echo "::warning::Code changes are too large (${CODE_SIZE} bytes) for a single scan. Please consider splitting the changes into smaller Pull Requests."
            # ÌïÑÏöîÏãú, PRÏóê ÏßÅÏ†ë ÏΩîÎ©òÌä∏Î•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÏäµÎãàÎã§.
            # gh pr comment ${{ github.event.pull_request.number }} --body "‚ö†Ô∏è **Warning:** The number of changes in this PR is too large to be scanned by Black Duck in a single operation. Please split this PR into smaller ones if a snippet scan is required."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Code size (${CODE_SIZE} bytes) is within the scannable range."

          # --- Í∏∞Ï°¥ Ïä§Ï∫î Î°úÏßÅ ÏãúÏûë ---

          AUTH_RESPONSE_FILE=$(mktemp)
          # Ïä§ÌÅ¨Î¶ΩÌä∏ Ï¢ÖÎ£å Ïãú ÏûÑÏãú ÌååÏùº ÏûêÎèô ÏÇ≠Ï†ú
          trap 'rm -f "$AUTH_RESPONSE_FILE"' EXIT

          AUTH_HTTP_CODE=$(curl -s -o "$AUTH_RESPONSE_FILE" -w "%{http_code}" -X POST \
            --header "Authorization: token ${BLACKDUCKSCA_TOKEN}" \
            "${BLACKDUCKSCA_URL%/}/api/tokens/authenticate")
          
          if [ "$AUTH_HTTP_CODE" -ne 200 ]; then
            echo "::error::Failed to get Bearer Token from Black Duck (HTTP Code: $AUTH_HTTP_CODE)"
            echo "::error::Response: $(cat $AUTH_RESPONSE_FILE)"
            exit 1
          fi

          BEARER_TOKEN=$(jq -r '.bearerToken' "$AUTH_RESPONSE_FILE")
          if [ -z "$BEARER_TOKEN" ] || [ "$BEARER_TOKEN" == "null" ]; then
            echo "::error::Bearer Token is empty. Authentication failed."
            echo "::error::Response: $AUTH_BODY"
            exit 1
          fi
          echo "Successfully obtained Bearer Token."

          SCAN_RESPONSE_FILE=$(mktemp)
          # Ïä§ÌÅ¨Î¶ΩÌä∏ Ï¢ÖÎ£å Ïãú ÏûÑÏãú ÌååÏùº ÏûêÎèô ÏÇ≠Ï†ú
          trap 'rm -f "$AUTH_RESPONSE_FILE" "$SCAN_RESPONSE_FILE"' EXIT

          SCAN_HTTP_CODE=$(curl -s -o "$SCAN_RESPONSE_FILE" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${BEARER_TOKEN}" \
            -H "Content-Type: text/plain" \
            -H "Accept: application/json" \
            --data-binary @changed_code.txt \
            "${BLACKDUCKSCA_URL%/}/api/snippet-matching")

          if [ "$SCAN_HTTP_CODE" -ne 200 ]; then
            echo "::error::Black Duck Snippet Scan API call failed (HTTP Code: $SCAN_HTTP_CODE)"
            echo "::error::Response: $(cat $SCAN_RESPONSE_FILE)"
            exit 1
          fi

          cat "$SCAN_RESPONSE_FILE" > scan_results.json
          echo "scan_completed=true" >> $GITHUB_OUTPUT
          echo "Snippet scan completed successfully."

      - name: Process scan results and comment on PR
        if: steps.bd_scan.outputs.scan_completed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const core = require('@actions/core');
            const path = require('path');
            const resultsPath = path.join(process.env.GITHUB_WORKSPACE, 'scan_results.json');
            
            if (!fs.existsSync(resultsPath)) {
              console.log('scan_results.json not found. Skipping comment.');
              return;
            }

            const response = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
            const results = response.items || [];

            if (results.length === 0) {
              console.log('No snippet matches found.');
              return;
            }

            let high_risk_found = false;
            let comment_body = '### :shield: Black Duck Snippet Scan Results\n\n';
            comment_body += 'The following open source snippets were detected in the added code:\n\n';
            
            const highRiskFamilies = ['RECIPROCAL', 'AGPL'];
            const mediumRiskFamilies = ['WEAK_RECIPROCAL'];

            let table_header = '| Risk | Component | Version | License | License Family |\n';
            table_header += '|:----:|:----------|:--------|:--------|:---------------|\n';
            let table_body = '';

            for (const match of results) {
              const component = match.matchingComponent || 'N/A';
              const version = match.version || 'N/A';
              const license = match.licenseName || 'UNKNOWN';
              const family = match.licenseFamily || 'UNKNOWN';
              
              let emoji = 'üü¢'; // Low risk
              if (highRiskFamilies.includes(family)) {
                emoji = 'üî¥'; // High risk
                high_risk_found = true;
              } else if (mediumRiskFamilies.includes(family)) {
                emoji = 'üü°'; // Medium risk
              }
              
              table_body += `| ${emoji} | `${component}` | `${version}` | ${license} | ${family} |\n`;
            }

            comment_body += table_header + table_body;

            if (high_risk_found) {
              comment_body += '\n\n**Action Required:** üî¥ High-risk license(s) (Reciprocal, AGPL) detected. A review from the legal/compliance team is required before merging.';
              core.setFailed('High-risk license snippets detected.');
            } else {
              comment_body += '\n\n**Notice:** üü¢ All detected snippets are within the acceptable license policy range.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment_body
            });
