name: Black Duck Snippet Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  snippet-scan:
    name: Black Duck Snippet Scan
    runs-on: ubuntu-latest

    env:
      BLACKDUCKSCA_URL: ${{ vars.BLACKDUCKSCA_URL }}
      BLACKDUCKSCA_TOKEN: ${{ secrets.BLACKDUCKSCA_TOKEN }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # fetch-depth: 0ì€ ì „ì²´ git íˆìŠ¤í† ë¦¬ë¥¼ ì²´í¬ì•„ì›ƒí•˜ì—¬,
        # git diff ëª…ë ¹ì— í•„ìš”í•œ baseì™€ head SHAë¥¼ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.
        with:
          fetch-depth: 0

      - name: Extract changed code from Pull Request
        id: extract_code
        run: |
          # --- ë””ë²„ê¹… ì •ë³´ ì¶œë ¥ ì‹œì‘ ---
          echo "::group::Debugging Git Information"
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"
          echo "Current Branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Verifying SHAs are present:"
          git cat-file -t ${{ github.event.pull_request.base.sha }} || echo "Base SHA not found locally!"
          git cat-file -t ${{ github.event.pull_request.head.sha }} || echo "Head SHA not found locally!"
          echo "::endgroup::"

          echo "::group::Raw git diff output"
          # awkë¡œ íŒŒì´í”„í•˜ê¸° ì „ì˜ ì›ë³¸ diff ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ì—¬ ì‹¤ì œ ë³€ê²½ ë‚´ìš©ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
          git diff --unified=0 ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }}
          echo "::endgroup::"
          # --- ë””ë²„ê¹… ì •ë³´ ì¶œë ¥ ë ---

          # PRì˜ ë³€ê²½ ì‚¬í•­ì„ ê°€ì¥ ì•ˆì •ì ìœ¼ë¡œ ì¶”ì¶œí•˜ê¸° ìœ„í•´ 'three-dot' diff (...)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
          # ì´ëŠ” 'base'ì™€ 'head'ì˜ ê³µí†µ ì¡°ìƒê³¼ 'head'ë¥¼ ë¹„êµí•˜ì—¬, ì´ PRì—ì„œ ë°œìƒí•œ ìˆœìˆ˜í•œ ë³€ê²½ë¶„ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
          # diff ë©”íƒ€ë°ì´í„°ë¥¼ í•„í„°ë§í•˜ê³  ìˆœìˆ˜ ì½”ë“œ ë¼ì¸ë§Œ íŒŒì¼ì— ì €ì¥í•©ë‹ˆë‹¤.
          git diff --unified=0 ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }} \
            | awk 'BEGIN {OFS=""} /^(diff|index|---)/ {next} /^\+\+\+/ {next} /^\+/ {print substr($0, 2)}' \
            > changed_code.txt

          if [ -s changed_code.txt ]; then
            echo "--- Code Snippets to be Scanned ---"
            cat changed_code.txt
            echo "-----------------------------------"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "No added or modified code lines found to scan in this Pull Request. Skipping snippet scan."
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Scan snippet with Black Duck API
        if: steps.extract_code.outputs.changed == 'true'
        id: bd_scan
        run: |
          MIN_SIZE=300    # ë°”ì´íŠ¸ ë‹¨ìœ„
          MAX_SIZE=50000  # ë°”ì´íŠ¸ ë‹¨ìœ„
          CODE_SIZE=$(wc -c < changed_code.txt)

          if [ "$CODE_SIZE" -lt "$MIN_SIZE" ]; then
            echo "::notice::Code changes are too small (${CODE_SIZE} bytes) to be scanned. Skipping Black Duck Snippet Scan."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$CODE_SIZE" -gt "$MAX_SIZE" ]; then
            echo "::warning::Code changes are too large (${CODE_SIZE} bytes) for a single scan. Please consider splitting the changes into smaller Pull Requests."
            # í•„ìš”ì‹œ, PRì— ì§ì ‘ ì½”ë©˜íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            # gh pr comment ${{ github.event.pull_request.number }} --body "âš ï¸ **Warning:** The number of changes in this PR is too large to be scanned by Black Duck in a single operation. Please split this PR into smaller ones if a snippet scan is required."
            echo "scan_completed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Code size (${CODE_SIZE} bytes) is within the scannable range."

          # --- ê¸°ì¡´ ìŠ¤ìº” ë¡œì§ ì‹œì‘ ---

          AUTH_RESPONSE_FILE=$(mktemp)
          # ìŠ¤í¬ë¦½íŠ¸ ì¢…ë£Œ ì‹œ ì„ì‹œ íŒŒì¼ ìë™ ì‚­ì œ
          trap 'rm -f "$AUTH_RESPONSE_FILE"' EXIT

          AUTH_HTTP_CODE=$(curl -s -o "$AUTH_RESPONSE_FILE" -w "%{http_code}" -X POST \
            --header "Authorization: token ${BLACKDUCKSCA_TOKEN}" \
            "${BLACKDUCKSCA_URL%/}/api/tokens/authenticate")
          
          echo "::group::Black Duck Auth API Response"
          cat "$AUTH_RESPONSE_FILE"
          echo "::endgroup::"

          if [ "$AUTH_HTTP_CODE" -ne 200 ]; then
            echo "::error::Failed to get Bearer Token from Black Duck (HTTP Code: $AUTH_HTTP_CODE)"
            echo "::error::Response: $(cat $AUTH_RESPONSE_FILE)"
            exit 1
          fi

          BEARER_TOKEN=$(jq -r '.bearerToken' "$AUTH_RESPONSE_FILE")
          if [ -z "$BEARER_TOKEN" ] || [ "$BEARER_TOKEN" == "null" ]; then
            echo "::error::Bearer Token is empty. Authentication failed."
            echo "::error::Response: $AUTH_BODY"
            exit 1
          fi
          echo "Successfully obtained Bearer Token."

          SCAN_RESPONSE_FILE=$(mktemp)
          # ìŠ¤í¬ë¦½íŠ¸ ì¢…ë£Œ ì‹œ ì„ì‹œ íŒŒì¼ ìë™ ì‚­ì œ
          trap 'rm -f "$AUTH_RESPONSE_FILE" "$SCAN_RESPONSE_FILE"' EXIT

          SCAN_HTTP_CODE=$(curl -s -o "$SCAN_RESPONSE_FILE" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${BEARER_TOKEN}" \
            -H "Content-Type: text/plain" \
            -H "Accept: application/json" \
            --data-binary @changed_code.txt \
            "${BLACKDUCKSCA_URL%/}/api/snippet-matching")

          echo "::group::Black Duck Snippet Scan API Response"
          cat "$SCAN_RESPONSE_FILE"
          echo "::endgroup::"

          if [ "$SCAN_HTTP_CODE" -ne 200 ]; then
            echo "::error::Black Duck Snippet Scan API call failed (HTTP Code: $SCAN_HTTP_CODE)"
            echo "::error::Response: $(cat $SCAN_RESPONSE_FILE)"
            exit 1
          fi

          cat "$SCAN_RESPONSE_FILE" > scan_results.json
          echo "scan_completed=true" >> $GITHUB_OUTPUT
          echo "Snippet scan completed successfully."

      - name: Process scan results and comment on PR
        if: steps.bd_scan.outputs.scan_completed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const resultsPath = path.join(process.env.GITHUB_WORKSPACE, 'scan_results.json');
            
            if (!fs.existsSync(resultsPath)) {
              console.log('scan_results.json not found. Skipping comment.');
              return;
            }

            const response = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
            // API ì‘ë‹µì˜ snippetMatches ê°ì²´ì—ì„œ ëª¨ë“  ë¼ì´ì„ ìŠ¤ íŒ¨ë°€ë¦¬ë³„ ë°°ì—´ì„ ìˆœíšŒí•©ë‹ˆë‹¤.
            const snippetMatches = response.snippetMatches || {};
            const results = [];
            for (const familyName in snippetMatches) {
              results.push(...snippetMatches[familyName]);
            }
            
            console.log(`Found ${results.length} total snippet matches.`);
            console.log('Scan results:', JSON.stringify(results, null, 2));

            if (results.length === 0) {
              console.log('No snippet matches found.');
              return;
            }

            let high_risk_found = false;
            let comment_body = '### :shield: Black Duck Snippet Scan Results\n\n';
            comment_body += 'The following open source snippets were detected in the added code:\n\n';
            
            const highRiskFamilies = ['RECIPROCAL', 'AGPL'];
            const mediumRiskFamilies = ['WEAK_RECIPROCAL'];

            let table_header = '| Risk | Component | Version | License | License Family |\n';
            table_header += '|:----:|:----------|:--------|:--------|:---------------|\n';
            let table_body = '';

            for (const match of results) {
              const component = match.projectName || 'N/A';
              const version = match.releaseVersion || 'N/A';
              const license = match.licenseDefinition?.spdxId || 'UNKNOWN';
              const family = match.licenseDefinition?.licenseFamilyName || 'UNKNOWN';
              
              let emoji = 'ğŸŸ¢'; // Low risk
              if (highRiskFamilies.includes(family)) {
                emoji = 'ğŸ”´'; // High risk
                high_risk_found = true;
              } else if (mediumRiskFamilies.includes(family)) {
                emoji = 'ğŸŸ¡'; // Medium risk
              }
              
              table_body += `| ${emoji} | \`${component}\` | \`${version}\` | ${license} | ${family} |\n`;
            }

            comment_body += table_header + table_body;

            if (high_risk_found) {
              comment_body += '\n\n**Action Required:** ğŸ”´ High-risk license(s) (Reciprocal, AGPL) detected. A review from the legal/compliance team is required before merging.';
              core.setFailed('High-risk license snippets detected.');
            } else {
              comment_body += '\n\n**Notice:** ğŸŸ¢ All detected snippets are within the acceptable license policy range.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment_body
            });
